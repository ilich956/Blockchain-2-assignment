import { PublicID } from '@self.id/core';
import { useAtom, useAtomValue, useSetAtom } from 'jotai';
import { useCallback } from 'react';
import { useMutation, useQuery, useQueryClient } from 'react-query';
import { stateScope, connectionAtom, clientAtom, viewerIDAtom } from './state.js';
import { abortable } from './utils.js';
export function useClient() {
    return useAtomValue(clientAtom, stateScope);
}
export function useViewerID() {
    return useAtomValue(viewerIDAtom, stateScope);
}
/**
 * Hook for handling the viewer's connection lifecycle, returning the following elements:
 *
 * 1. The current {@linkcode ViewerConnectionState} object.
 * 2. A connection attempt function, taking an `EthereumAuthProvider` argument.
 * 3. A reset function, clearing the current {@linkcode ViewerID}.
 */ export function useViewerConnection() {
    const client = useClient();
    const [connection, setConnection] = useAtom(connectionAtom, stateScope);
    const setViewerID = useSetAtom(viewerIDAtom, stateScope);
    const connect = useCallback(async (provider, sessionStr)=>{
        if (connection.status === 'connecting' && connection.provider === provider) {
            return await connection.promise;
        }
        if (connection.status === 'connecting') {
            connection.promise.abort();
        }
        try {
            const promise = abortable(client.authenticate(provider, sessionStr).then((selfID)=>{
                if (promise.signal.aborted) {
                    void setConnection({
                        status: 'idle'
                    });
                    return null;
                }
                void setViewerID(selfID);
                return selfID;
            }));
            void setConnection({
                status: 'connecting',
                provider,
                promise
            });
            return await promise;
        } catch (err) {
            void setConnection({
                status: 'failed',
                error: err
            });
            return null;
        }
    }, [
        client,
        connection,
        setConnection,
        setViewerID
    ]);
    const reset = useCallback(()=>{
        void setViewerID(null);
    }, [
        setViewerID
    ]);
    return [
        connection,
        connect,
        reset
    ];
}
/**
 * Hook for accessing the {@linkcode ViewerRecord} for a given alias.
 */ export function useViewerRecord(alias) {
    const viewerID = useViewerID();
    const key = [
        viewerID?.id,
        alias
    ];
    const queryClient = useQueryClient();
    const { data , isLoading , isError , error  } = useQuery(key, async ()=>viewerID ? await viewerID.get(alias) : null);
    const mutationOptions = {
        onSuccess: (content)=>{
            queryClient.setQueryData(key, content);
        }
    };
    const setMutation = useMutation(async (content)=>{
        if (viewerID == null || viewerID instanceof PublicID) {
            throw new Error('Cannot mutate record');
        }
        await viewerID.set(alias, content);
        return content;
    }, mutationOptions);
    const mergeMutation = useMutation(async (content)=>{
        if (viewerID == null || viewerID instanceof PublicID) {
            throw new Error('Cannot mutate record');
        }
        const newContent = {
            ...data ?? {},
            ...content
        };
        await viewerID.set(alias, newContent);
        return newContent;
    }, mutationOptions);
    return viewerID == null ? {
        isLoadable: false,
        isLoading: false,
        isError: false,
        isMutable: false,
        isMutating: false
    } : {
        content: data,
        isLoadable: true,
        isLoading,
        isError,
        error,
        isMutable: !(viewerID instanceof PublicID),
        isMutating: setMutation.isLoading || mergeMutation.isLoading,
        set: async (content)=>{
            await setMutation.mutateAsync(content);
        },
        merge: async (content)=>{
            await mergeMutation.mutateAsync(content);
        }
    };
}
/**
 * Hook for accessing the {@linkcode PublicRecord} for a given alias and account (DID or CAIP-10).
 */ export function usePublicRecord(alias, id) {
    const client = useClient();
    const { data , isLoading , isError , error  } = useQuery([
        id,
        alias
    ], async ()=>await client.get(alias, id));
    return {
        content: data,
        isLoading,
        isError,
        error
    };
}
