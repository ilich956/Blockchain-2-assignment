function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
import { WebClient } from './client.js';
import { WebClientSession } from './clientSession.js';
var _client = /*#__PURE__*/ new WeakMap();
/**
 * A SelfID instance provides a client for an authenticated DID. Beyond loading records, it also
 * allows to mutate them.
 *
 * It is exported by the {@linkcode web} module.
 *
 * ```sh
 * import { SelfID } from '@self.id/web'
 * ```
 */ export class SelfID {
    /** Create a SelfID instance by authenticating using the given provider. */ static async authenticate(params) {
        const { authProvider , threeidConnect , ...clientParams } = params;
        const client = threeidConnect ? new WebClient(clientParams) : new WebClientSession(clientParams);
        await client.authenticate(authProvider, true, clientParams.sessionStr);
        return new SelfID({
            client
        });
    }
    get client() {
        return _classPrivateFieldGet(this, _client);
    }
    /** DID instance used internally. */ get did() {
        const did = _classPrivateFieldGet(this, _client).ceramic.did;
        if (did == null || !did.authenticated) {
            throw new Error('Expected authenticated DID instance to be attached to Ceramic');
        }
        return did;
    }
    /** DID string associated to the SelfID instance. */ get id() {
        return this.did.hasParent ? this.did.parent : this.did.id;
    }
    // Definitions interactions
    /** Load the record contents for a given definition alias. */ async get(key) {
        return await _classPrivateFieldGet(this, _client).dataStore.get(key, this.id);
    }
    /**
   * Set the record contents for a given definition alias.
   *
   * ⚠️ Using this method will **replace any existing content**. If you only want to write some
   * fields and leave existing ones unchanged, you can use the {@linkcode merge} method instead.
   */ async set(key, content) {
        return await _classPrivateFieldGet(this, _client).dataStore.set(key, content);
    }
    /**
   * Merge the record contents for a given definition alias. If no content exists, the record will
   * be created.
   *
   * ⚠️ This method only performs a shallow (one level) merge using {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign Object.assign}.
   * For a deep merge or a specific merging strategy, you will need to implement custom logic.
   */ async merge(key, content) {
        return await _classPrivateFieldGet(this, _client).dataStore.merge(key, content);
    }
    constructor(params){
        _classPrivateFieldInit(this, _client, {
            writable: true,
            value: void 0
        });
        if (!params.client.ceramic.did?.authenticated) {
            throw new Error('Input DID must be authenticated, use SelfID.authenticate() instead of new SelfID()');
        }
        _classPrivateFieldSet(this, _client, params.client);
    }
}
