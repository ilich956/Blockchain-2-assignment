import type { EthereumAuthProvider } from '@3id/connect';
import type { StreamID } from '@ceramicnetwork/streamid';
import type { DefinitionContentType } from '@glazed/did-datastore';
import type { ModelTypeAliases } from '@glazed/types';
import type { CoreModelTypes } from '@self.id/core';
import type { DID } from 'dids';
import { WebClient } from './client.js';
import { WebClientSession } from './clientSession.js';
import type { WebClientParams } from './client.js';
export declare type AuthenticateParams<ModelTypes extends ModelTypeAliases = CoreModelTypes> = WebClientParams<ModelTypes> & {
    /** Authentication provider. */
    authProvider: EthereumAuthProvider;
    sessionStr?: string;
};
export declare type SelfIDParams<ModelTypes extends ModelTypeAliases = CoreModelTypes> = {
    /** {@linkcode WebClient} instance to use. It must have an authenticated DID attached to it. */
    client: WebClient<ModelTypes> | WebClientSession<ModelTypes>;
};
/**
 * A SelfID instance provides a client for an authenticated DID. Beyond loading records, it also
 * allows to mutate them.
 *
 * It is exported by the {@linkcode web} module.
 *
 * ```sh
 * import { SelfID } from '@self.id/web'
 * ```
 */
export declare class SelfID<ModelTypes extends ModelTypeAliases = CoreModelTypes, Alias extends keyof ModelTypes['definitions'] = keyof ModelTypes['definitions']> {
    #private;
    /** Create a SelfID instance by authenticating using the given provider. */
    static authenticate<ModelTypes extends ModelTypeAliases = CoreModelTypes>(params: AuthenticateParams<ModelTypes>): Promise<SelfID<ModelTypes>>;
    constructor(params: SelfIDParams<ModelTypes>);
    get client(): WebClient<ModelTypes> | WebClientSession<ModelTypes>;
    /** DID instance used internally. */
    get did(): DID;
    /** DID string associated to the SelfID instance. */
    get id(): string;
    /** Load the record contents for a given definition alias. */
    get<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(key: Key): Promise<ContentType | null>;
    /**
     * Set the record contents for a given definition alias.
     *
     * ⚠️ Using this method will **replace any existing content**. If you only want to write some
     * fields and leave existing ones unchanged, you can use the {@linkcode merge} method instead.
     */
    set<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(key: Key, content: ContentType): Promise<StreamID>;
    /**
     * Merge the record contents for a given definition alias. If no content exists, the record will
     * be created.
     *
     * ⚠️ This method only performs a shallow (one level) merge using {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign Object.assign}.
     * For a deep merge or a specific merging strategy, you will need to implement custom logic.
     */
    merge<Key extends Alias, ContentType = DefinitionContentType<ModelTypes, Key>>(key: Key, content: ContentType): Promise<StreamID>;
}
