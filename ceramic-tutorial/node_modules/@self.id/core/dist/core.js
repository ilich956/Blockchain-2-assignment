function _checkPrivateRedeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
    return _classApplyDescriptorGet(receiver, descriptor);
}
function _classPrivateFieldInit(obj, privateMap, value) {
    _checkPrivateRedeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
    _classApplyDescriptorSet(receiver, descriptor, value);
    return value;
}
import { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver';
import { CeramicClient } from '@ceramicnetwork/http-client';
import { Caip10Link } from '@ceramicnetwork/stream-caip10-link';
import { DataModel } from '@glazed/datamodel';
import { DIDDataStore } from '@glazed/did-datastore';
import { TileLoader } from '@glazed/tile-loader';
import { Resolver } from 'did-resolver';
import { getResolver as getKeyResolver } from 'key-did-resolver';
import { aliases as coreAliases } from './__generated__/model.js';
import { isCAIP10string, isDIDstring } from './utils.js';
/** @internal */ export const CERAMIC_URLS = {
    local: 'http://localhost:7007',
    'mainnet-gateway': 'https://gateway.ceramic.network',
    'testnet-clay': 'https://ceramic-clay.3boxlabs.com',
    'testnet-clay-gateway': 'https://gateway-clay.ceramic.network'
};
var _dataModel = /*#__PURE__*/ new WeakMap(), _resolver = /*#__PURE__*/ new WeakMap(), _tileLoader = /*#__PURE__*/ new WeakMap();
/**
 * Core client for the Self.ID SDK, exported by the {@linkcode core} module.
 *
 * ```sh
 * import { Core } from '@self.id/core'
 * ```
 */ export class Core {
    /** Ceramic HTTP Client instance used internally. */ get ceramic() {
        return this._ceramic;
    }
    /** DataModel runtime instance used internally. */ get dataModel() {
        return _classPrivateFieldGet(this, _dataModel);
    }
    /** DID DataStore instance used internally. */ get dataStore() {
        return this._dataStore;
    }
    /** DID resolver instance used internally. */ get resolver() {
        return _classPrivateFieldGet(this, _resolver);
    }
    /** Tile loader instance used internally. */ get tileLoader() {
        return _classPrivateFieldGet(this, _tileLoader);
    }
    /**
   * Load the DID string for a given CAIP-10 account using a CAIP-10 link, or throw an error if
   * not linked.
   */ async getAccountDID(account) {
        const link = await Caip10Link.fromAccount(this._ceramic, account);
        if (link.did == null) {
            throw new Error(`No DID found for ${account}`);
        }
        return link.did;
    }
    /**
   * Turn a DID or CAIP-10 string into a DID string.
   *
   * If the input is a DID string, it will be returned as-is, otherwise
   * {@linkcode getAccountDID} will be used.
   */ async toDID(accountOrDID) {
        if (isDIDstring(accountOrDID)) {
            return accountOrDID;
        }
        return isCAIP10string(accountOrDID) ? await this.getAccountDID(accountOrDID) : accountOrDID;
    }
    /**
   * Load the record content for a given definition alias and account.
   *
   * Uses {@linkcode toDID} to resolve the account.
   */ async get(key, id) {
        const did = await this.toDID(id);
        return await this._dataStore.get(key, did);
    }
    constructor(params){
        _classPrivateFieldInit(this, _dataModel, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _resolver, {
            writable: true,
            value: void 0
        });
        _classPrivateFieldInit(this, _tileLoader, {
            writable: true,
            value: void 0
        });
        const ceramic = new CeramicClient(CERAMIC_URLS[params.ceramic] ?? params.ceramic);
        const loader = params.loader ?? new TileLoader({
            ceramic,
            cache: params.cache
        });
        this._ceramic = ceramic;
        _classPrivateFieldSet(this, _dataModel, new DataModel({
            loader,
            aliases: params.aliases ?? coreAliases
        }));
        this._dataStore = new DIDDataStore({
            ceramic,
            loader,
            model: _classPrivateFieldGet(this, _dataModel)
        });
        _classPrivateFieldSet(this, _resolver, new Resolver({
            ...getKeyResolver(),
            ...get3IDResolver(this._ceramic)
        }));
        _classPrivateFieldSet(this, _tileLoader, loader);
    }
}
